<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单代码克隆检测]]></title>
    <url>%2F2018%2F06%2F10%2Fexperment2%2F</url>
    <content type="text"><![CDATA[今天主要将昨天得到的数据，放到之前看到的模型中跑了一下，看了一下效果，简单叙述一下实验。 实验思路： 将提取的Scala叶子节点的特征作为文本数据，输入到AutoenCODE中 ：AutoenCODE is a Deep Learning infrastructure that allows to encode source code fragments into vector representations, which can be used to learn similarities. https://github.com/micheletufano/AutoenCODE基本上所有的代码这个网站已经提供了，所以只要将代码clone到本地，配置一下环境就可以开始我们的实验。具体的AutoenCODE的原理，我会在以后的博客中详细的解释，本篇博客主要讲如何使用这个框架。 实验步骤： 按照AutoenCODE给的教程，第一步是将我们整理的数据转化成词向量，这里他使用的工具是word2vec，这里注意一下，他的这个word2vec需要build但是windows系统不支持这个build，所以我将转化词向量的这部分的工作转移到了centos服务器上进行，最终得到了测试样本的所有的词向量的数据。 接下来就将这个词向量输入到Recursive Autoencoder(论文中提及是一个斯坦福的情感分析器)中去，最终得到五个结果文件(这里提及一点，训练时间实在是太长了，源代码是使用matlab写的。27000条数据整整跑了一个小时，而且CUP满负荷运行，可能是我的电脑配置低，之后需要优化)。分别是： data.mat contains the input data including the corpus, vocabulary (a 1-by-|V| cell array), and We (the m-by-|V| word embedding matrix where m is the size of the word vectors). So columns of We correspond to word embeddings. corpus.dist.matrix.mat contains the distance matrix saved as matlab file. The values in the distance matrix are doubles that represent the Euclidean distance between two sentences. In particular, the cell (i,j) contains the Euclidean distance between the i-th sentence (i.e., i-th line in corpus.src) and the j-th sentence in the corpus. corpus.dist.matrix.csv contains the distance matrix saved as .csv file. corpus.sentence_codes.mat contain the embeddings for each sentence in the corpus. The sentence_codes object contains the representations for sentences, and the pairwise Euclidean distance between these representations are used to measure similarity. detector.mat contains opttheta (the trained clone detector), hparams, and options. 这里对我们最有用的就是那个矩阵，它显示两句话的距离大小，越小越相似。那么大的矩阵，怎么进行分析！！，只能硬着头皮通过写matlab代码，将矩阵中每行的最小值（非零）提取出来，这样就能得到27000多个最小值，然后再通过这27000个最小值进行筛选，因为本次实验主要看一下效果所以没有注意到那么多的细节，先把最小值求出来先看看。然后我将最小值又进行了划分，论文中说他们的想法是如果距离小于1e-8就认为他们是克隆的代码，然后我以这个为分界线进行了筛选，发现只有5对符合要求，最终的结果在最终结果那里进行展示。求取最小值代码： 实验结果： 当判断距离为1e-8时(5对) 当判断距离为1e-4时(75对) 当判断距离为1e-2时(800多对)通过观察主要分为以下几个类型： 函数重载和相似函数(在同一个文件中)(5对)(800多对)(75对)(75对)D:\Git\spark\core\src\test\scala\org\apache\spark\deploy\master\MasterSuite.scalaD:\Git\spark\core\src\test\scala\org\apache\spark\deploy\master\MasterSuite.scala(75对) 父子继承关系或者同时继承同一个父类的子类之间(不同文件)D:\Git\spark\core\src\main\scala\org\apache\spark\scheduler\DAGScheduler.scala (父类)D:\Git\spark\core\src\test\scala\org\apache\spark\scheduler\TaskSetManagerSuite.scala (子类)(75对)D:\Git\spark\core\src\test\scala\org\apache\spark\scheduler\SparkListenerWithClusterSuite.scalaD:\Git\spark\core\src\test\scala\org\apache\spark\deploy\LogUrlsStandaloneSuite.scala(800对) 相似或者相同的函数(不同文件)D:\Git\spark\core\src\main\scala\org\apache\spark\util\collection\PrimitiveKeyOpenHashMap.scalaD:\Git\spark\graphx\src\main\scala\org\apache\spark\graphx\util\collection\GraphXPrimitiveKeyOpenHashMap.scala(75对)D:\Git\spark\core\src\main\scala\org\apache\spark\deploy\history\HistoryServerArguments.scalaD:\Git\spark\core\src\main\scala\org\apache\spark\deploy\worker\WorkerArguments.scala(75对) 不像是克隆的函数(我的观点)D:\Git\spark\core\src\main\scala\org\apache\spark\status\LiveEntity.scalaD:\Git\spark\core\src\main\scala\org\apache\spark\status\LiveEntity.scala(75对) 实验总结： 由于时间和人手有限，现在只是对这几个结果进行了分析，还有很多对都没有看，之后找时间看看还有没有其他类型，或者老师可以分配几个人帮我看看。 附录： 在得到结果以后，这是忘了如何去找源文件，这里我在原来的parse的基础上加上了一个统计样本所在的文件的文件，通过行数来查找对应的文件，感觉很费时费力。]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>code_detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST树提取进展]]></title>
    <url>%2F2018%2F06%2F09%2Fexperment1%2F</url>
    <content type="text"><![CDATA[今天主要把昨天没有做完的工作进行了扩展，由提取单一文件的叶子节点扩展到提取到整个项目的叶子节点，然后将类级别的数据修改成方法级别的数据 实验步骤： 按照昨天写的代码，只需要加一个循环遍历文件的函数就可以了 然后第一个问题出现了，scala meta 这个工具还不是很成熟，对于部分文件在parse的时候会抛出异常 在网上查了好久，网上也有许多人遇到这个问题，但是scala meta并没有提供解决的办法。经过不懈的努力，最终在评论区找到了解决方法，这个bug主要是s&quot;xxxxxxx&quot;后面直接换行引起的(黑人问号)，只要在\n后面加一个空格就可以了(黑人问号)。 所以我就对我们输入的数据进行了预处理，所有包含字符串s&quot;xxxxx&quot;的行的\n都进行了变换。 第二个问题，嵌套函数的问题，因为我们测试的数据是在方法级别上的进行抽取，所以就会出现嵌套函数的问题，具体的嵌套函数的示例如下图所示： 在这里的问题主要是将子函数抽取出来作为一条数据还是将子函数作为一条像if语句那样的句子作为父函数的一部分，经过跟几位老师讨论，我们决定采用第一种方式，原因是第一子函数的粒度小，第二就是在函数的功能上面还是子函数为主，对于第四种类型的代码克隆的判断来说更加有利。所以我利用栈的思想将子函数剥离出来：最终的结果是： 其中13是父函数，12是子函数。 最终结果： 成功提取spark代码里面的27042条样本，明天开始进行测试算法效果，并且再读一遍论文，整理一下文档加油！！！！ 还要好好学一下英语和线代和算法！！！]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>AST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST]]></title>
    <url>%2F2018%2F06%2F08%2FAST%2F</url>
    <content type="text"><![CDATA[Scala AST 叶子节点提取 背景： 前几天由于考试没有来得及整理基础知识，今天在这里先整理一下这两天做的Scala叶子节点的值提取 Scala 是一门多范式（multi-paradigm）的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。Scala 运行在Java虚拟机上，并兼容现有的Java程序。Scala 源代码被编译成Java字节码，所以它可以运行于JVM之上，并可以调用现有的Java类库。(百度百科） 实验步骤： 使用的工具： scala meta : https://scalameta.org/ Intellij Idea: https://www.jetbrains.com/idea/ 借助的参考资料： scala meta的示例程序 浏览器 构造 scala AST 树：https://astexplorer.net/#/gist/22cf8a3fcb2155c087ae94b4d194c1b6/d10c646ecfae4c69c919408aa3aaefb2deda2df7 实验带代码： 查看 scala meta 源程序可以发现 ，该工具里面有一个Tree的类，该类有children 属性和parent属性： 所以可以根据这个类来进行遍历得到我们需要的叶子节点的数据，在这里我采用visitor的方式来进行遍历。主要的遍历的对象有以下几个： 分别代表Scala中的各个语法，这里在做的时候出现了几个问题。一个是Term.param和Type.param 需要“精准的查找”，不能像其他的Term.Name,Term.Annonate那样，可以通过Term来进行查找： 也就是说其他的Term里面的属性可以通过遍历Term然后再进行查找，但是这个Term.param必须在第一次遍历的时候就指出来，难道Term.param不属于Term?很奇怪。以后再查一查。 代码的逻辑并不难，下面就开始打印叶子节点，通过观察浏览器AST解析器https://astexplorer.net/#/gist/22cf8a3fcb2155c087ae94b4d194c1b6/d10c646ecfae4c69c919408aa3aaefb2deda2df7发现：叶子节点主要在以下几个地方打印：基本数据类型Term.Name处Type.Name 处还有一个是Name处 实验的最终结果： Scala 源代码 提取的叶子节点 源代码 提取的叶子节点 总结：实验结果还未仔细观察，具体的细节有待改进，还有就是上次说的将string值改成等基本数据的转化还未加入。 本博客持续更新。]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>AST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记]]></title>
    <url>%2F2018%2F06%2F06%2Fdaily1%2F</url>
    <content type="text"><![CDATA[Please enter the password to read. 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]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习提纲]]></title>
    <url>%2F2018%2F06%2F01%2Fsoftware-review%2F</url>
    <content type="text"><![CDATA[本博客是根据软件工程最后一节重点课总结的内容，对软件工程的知识进行了简单的梳理 软件工程简述 软件工程定义： 软件工程是研究应用如何以系统性的、规范化的、可定量的过程化方法 去开发和维护软件， 以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术结合起来]]></content>
      <categories>
        <category>学科复习</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
</search>
